from fastapi import APIRouter, HTTPException, Depends, BackgroundTasksfrom typing import List, Optional, Dict, Anyfrom datetime import datetime, timedeltafrom bson import ObjectIdfrom models.database import databasefrom models.schemas import (    ApiExportConfig, ApiExportConfigCreate, ApiExportConfigUpdate,    ApiExportJob, ApiExportJobCreate, ApiExportLog, ApiExportStats)from services.api_export_service import ApiExportServiceimport logginglogger = logging.getLogger(__name__)router = APIRouter(prefix="/api-export", tags=["API Export"])# Dependency to get the API export servicedef get_api_export_service() -> ApiExportService:    return ApiExportService()@router.get("/configs", response_model=List[ApiExportConfig])async def list_export_configs(    skip: int = 0,    limit: int = 100,    active_only: bool = False):    """List all API export configurations"""    try:        db = database.get_database()        query = {}        if active_only:            query["is_active"] = True                    cursor = db.api_export_configs.find(query).skip(skip).limit(limit).sort("created_at", -1)        configs = []                async for config in cursor:            config["_id"] = str(config["_id"])            configs.append(ApiExportConfig(**config))                    return configs    except Exception as e:        logger.error(f"Error listing export configs: {e}")        raise HTTPException(status_code=500, detail="Failed to fetch export configurations")@router.post("/configs", response_model=ApiExportConfig)async def create_export_config(config: ApiExportConfigCreate):    """Create a new API export configuration"""    try:        db = database.get_database()                # Check if name already exists        existing = await db.api_export_configs.find_one({"name": config.name})        if existing:            raise HTTPException(status_code=400, detail="Configuration name already exists")                config_dict = config.dict()        config_dict["created_at"] = datetime.utcnow()        config_dict["updated_at"] = datetime.utcnow()                result = await db.api_export_configs.insert_one(config_dict)        config_dict["_id"] = str(result.inserted_id)                logger.info(f"Created export config: {config.name}")        return ApiExportConfig(**config_dict)    except HTTPException:        raise    except Exception as e:        logger.error(f"Error creating export config: {e}")        raise HTTPException(status_code=500, detail="Failed to create export configuration")@router.get("/stats", response_model=ApiExportStats)async def get_export_stats():    """Get API export statistics"""    try:        db = database.get_database()                # Get basic counts with fallbacks for new installations        total_configs = await db.api_export_configs.count_documents({})        active_configs = await db.api_export_configs.count_documents({"is_active": True})        total_jobs = await db.api_export_jobs.count_documents({})                # Jobs created today        today_start = datetime.utcnow().replace(hour=0, minute=0, second=0, microsecond=0)        jobs_today = await db.api_export_jobs.count_documents({"created_at": {"$gte": today_start}})                # Total exported records        total_exported_records = 0        recent_jobs = []                return ApiExportStats(            total_configs=total_configs,            active_configs=active_configs,            total_jobs=total_jobs,            jobs_today=jobs_today,            total_exported_records=total_exported_records,            recent_jobs=recent_jobs        )    except Exception as e:        logger.error(f"Error fetching export stats: {e}")        raise HTTPException(status_code=500, detail="Failed to fetch export statistics")@router.post("/test-connection")async def test_api_connection(    endpoint_url: str,    bearer_token: str,    service: ApiExportService = Depends(get_api_export_service)):    """Test connection to an API endpoint"""    try:        result = await service.test_api_connection(endpoint_url, bearer_token)        return result    except Exception as e:        logger.error(f"Error testing API connection: {e}")        raise HTTPException(status_code=500, detail="Failed to test API connection")